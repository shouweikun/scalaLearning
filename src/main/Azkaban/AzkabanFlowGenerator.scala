import Excel.ExcelUtils

import jxl.format.CellFormat
import jxl.{Cell, CellFeatures, CellType, Sheet}
import org.apache.commons.cli.{DefaultParser, Options}

import scala.sys.process._
import scala.reflect.runtime.{universe => ru}


/**

  */
object AzkabanFlowGenerator  {

  val excelUtils = new ExcelUtils
  val newCell    = getblankcell
  lazy val  mysqlUtil = new MysqlUtil("jdbc:mysql://192.168.143.131:3307/etl_dm","prod_hanxiaoqiang","prod_hanxiaoqiang.jKcKnsDBDoNCymr5xvnrJqf4GMqmBs4T")
  var byindex      ="false"
  var filenameMap  = Map.empty[Int,String]
  var dstpath       = ""
  var srcpath       = ""
  var url           = ""
  var tbname        = ""

  //var count      = 0
  def main(args: Array[String]): Unit = {
    val option = new Options
    option.addOption("dst",true,"path for set file")
    option.addOption("src",true,"path for excel file")
    option.addOption("url",true,"azkaban url")
    option.addOption("tbname",true,"tbname for backup")
    option.addOption("compress",false,"compress file or not")
    option.addOption("index",false,"dependency generated by index")
    option.addOption("d",false,"reset the dir")
    //option.addOption("s",true,"script path")

    val parser = new DefaultParser()
    val c1     = parser.parse(option,args)

    this.dstpath = Option(c1.getOptionValue("dst")).getOrElse("")
    this.dstpath =if (dstpath.endsWith("/")) dstpath.substring(0,dstpath.lastIndexOf("/")) else dstpath
    this.srcpath = Option(c1.getOptionValue("src")).getOrElse("")
    this.url     = Option(c1.getOptionValue("url")).getOrElse("")
    this.tbname  =Option(c1.getOptionValue("tbname")).getOrElse("azkabanjob")
   if(c1.hasOption("index")) { this.byindex ="true"}
      if(dstpath==""||srcpath=="")
      {
        println("lack parameter :dst/src,please check")
        sys.exit(1)
      }
    if(c1.hasOption("d"))
      {
        println("reset dir")
        resetdir
      }
    var filename = ""
    println("process excel to generate azkaban files")
    readExcelandExecute(Excelvaildation)(EncapsulationintoAzkabanJob)
    if(c1.hasOption("compress")) {
      println("compress files to a zip")
      filename = compressfile
    }
    if(url.trim != "") {
      println("upload the zip to azkaban")
      senttoAzkaban(filename)
    }
  }
  //Excel 处理


  def readExcelandExecute (vaildationfunction:Sheet=>Any)(prcessingfunction:Sheet => Any)= {
    val workbook = excelUtils.readWorkbook(srcpath)
    val sheet    = workbook.getSheet("Azkaban")
    vaildationfunction(sheet)
    prcessingfunction(sheet)
}
  def Excelvaildation(sheet: Sheet) ={
    val rowscount = sheet.getRows
    val metadata  = sheet.getRow(0)
    val dependencyindex =(0 until metadata.size).map{i=>
      (metadata(i).getContents.trim->i)
    }.toMap.get("dependencies").get
    val jobnameindex =(0 until metadata.size).map{i=>
      (metadata(i).getContents.trim->i)
    }.toMap.get("job_name").get
    val dependencies = sheet.getColumn(dependencyindex)


    if(byindex!="false"){
      dependencies.par.filter{
        dep=>(dep.getContents.trim!="") && (dep.getContents.trim !="dependencies")
      }.map{
        dep=>
          dep.getContents.split(",").map{
          x=>
            println(x)
            if(Integer.parseInt(x.trim)>rowscount)
            {
              println("fuck ,index over max")
              sys.exit(1)
            }

        }
      }
    }else{
      val jobnames     = sheet.getColumn(jobnameindex).filter{
        jobname=>
          jobname.getContents.trim!="job_name" &&jobname.getContents.trim!=""
      }.flatMap(_.getContents.split(",")).map(_.trim)

      val jobnamesafterdistinct  = jobnames.distinct

      if( jobnames.size != jobnamesafterdistinct.size)
        {
          println(s"these following table is depulicated>>>>${jobnames.diff(jobnamesafterdistinct).mkString(",")}")
        }
      val jobnameset = jobnames.toSet
      val wrongdependencies =dependencies.filter{dep =>
        (dep.getContents.trim!="") && (dep.getContents.trim !="dependencies")
      }.par.filter{
        dependency=>
          var flag = false

          dependency.getContents.split(",").foreach{x=>if(!jobnameset.contains(x)){
            flag = true
          }

      }
          flag
      }
      if (wrongdependencies.size != 0)
        {
          wrongdependencies.foreach{
            wrong=>
            println(s"denpendency(s) cannot be resolved:Row${wrong.getRow+1},content:${wrong.getContents}")}
          sys.exit(1)
        }

    }

  }
  def methodchooser(jobtype :String)(path:String)(rowinfo :Map[String,Cell]) =  jobtype.toLowerCase.trim match {
    case "command" =>matchFieldsbyReflection(classOf[CommandJob])(rowinfo)(path)
    case "flow"    =>matchFieldsbyReflection(classOf[FlowJob])(rowinfo)(path)
    case ""        =>println(s"lack of jobtype") ;""
    //TODO JavaJob etc.
    //case "JavaJob"    =>
  }
  def EncapsulationintoAzkabanJob(sheet:Sheet)={
    val rows = Range(1,sheet.getRows)
    val metaData = sheet.getRow(0).map(_.getContents)
    val dataset = rows.map{
      index => metaData zip sheet.getRow(index) toMap
    }
    var count  = 2

    dataset.foreach{
      rowinfo =>val jobtype = rowinfo.get("type").getOrElse(newCell).getContents
       // try{
       val filename = methodchooser(jobtype)(dstpath)(rowinfo)
       filenameMap = filenameMap + (count -> filename)
       // }catch{
        //  case e:Exception =>println(s"fuck,${e}")
       // }finally {
          count += 1
          //writeintodatabase(rowinfo)
          //filenameMap =filenameMap +（count -> filename)


        //}
    }
    mysqlUtil.close()

  }

  def matchFieldsbyReflection[T <:AzkabanJob](classinfo :Class[T])(rowinfo :Map[String,Cell])(path:String) :String= {

   val fieldinTclass =classinfo.getDeclaredFields
   val fieldsinAzkabanJob = classOf[AzkabanJob].getDeclaredFields
   val allfields         = fieldinTclass ++ fieldsinAzkabanJob
  // val makefilemethod    = classinfo.getDeclaredMethods.filter(_.getName.eq("makefile"))(0)
   val instance          = classinfo.newInstance()


    allfields.map{
      field =>
        val fieldname = field.getName.toLowerCase.trim
       //val fieldclassTag =ru.CLASSClass.forName(field.getType.getName)
        //todo as instanceof[T]
        field.setAccessible(true)
        //println(fieldname)
        field.set(instance,rowinfo.get(fieldname).getOrElse(newCell).getContents)
//        println(s"${field.getName},${field.get()}")
      //.asInstanceOf[fieldclassTag])

    }
    if(byindex != "false") {
      val dependencies = instance.dependencies.split(",").filter(_ != "").map {
        index => filenameMap.getOrElse(Integer.parseInt(index), new Exception("fuck,index match 0"))

      }.mkString(",")
      instance.dependencies = dependencies
      if(instance.isInstanceOf[FlowJob])
        {
          val index = instance.asInstanceOf[FlowJob].Flow_name
           instance.asInstanceOf[FlowJob].Flow_name =filenameMap.getOrElse(Integer.parseInt(index), new Exception("cannot match flow name")).asInstanceOf[String]

        }

    }
   val abspath  = if(path.endsWith("/"))path else s"$path/"
   val filename = rowinfo.get("job_name").getOrElse(newCell).getContents
   val realfilename = if (filename.trim ==""||filename ==null) {
      val index = rowinfo.get("index").getOrElse(newCell).getContents
      val table = rowinfo.get("tablename").getOrElse(newCell).getContents
      val operation = rowinfo.get("operation").getOrElse(newCell).getContents
      s"${index}_${operation}_${table}"
    }else s"$filename"
    instance.Job_Name = realfilename
    val filepath =s"$abspath$filename"
    instance.makefile(filepath)
     realfilename
  }
  def compressfile: String ={
    val dst = if (dstpath.endsWith("/")) dstpath.substring(0,dstpath.lastIndexOf("/")) else dstpath
    val filename = s"generated_from_${dst.substring(dstpath.lastIndexOf("/")+1)}"
    //val cddir   = s"cd $dst"!
    val command = s"zip -r $dst/$filename.zip $dst"!;
    return  filename
  }
  def resetdir = {
    val remove = s"rm -rf $dstpath" !
    var create = s"mkdir $dstpath"  !
  }

  def senttoAzkaban(filename:String) = {
    //todo sent file to azkaban
    ???
  }
  def writeintodatabase(rowinfo:Map[String,Cell])={
    val pre = s"INSERT INTO ${this.tbname}"
    var fields = "("
    var values = "("
    rowinfo.foreach{
      x=>
        //println(s"${x._1}")
        //println(s"${x._2}")

        fields += s"${x._1},"
        println(fields)
        values += s"'${x._2}',"
        println(values)
    }
    if (fields.endsWith(",")) {
      fields = fields.substring(0,fields.length-1)
    }
    println(fields)
    if (values.endsWith(",")){
      values = values.substring(0,values.length-1)
    }
   // println(values)
    //    fields+")"
    //    values+")"
    val sql = s"$pre${fields}) VALUES ${values})"
    println(sql)
    mysqlUtil.insertSql(sql)
  }
  def getTypeTag[T:ru.TypeTag](Obj:T) =ru.typeTag[T]

  def getblankcell = {
  new Cell {override def getCellFormat: CellFormat = ???

    override def getRow: Int = ???

    override def isHidden: Boolean = ???

    override def getCellFeatures: CellFeatures = ???

    override def getType: CellType = ???

    override def getContents: String = ""

    override def getColumn: Int = ???
      }
//  def getTypeTag[T:ru.TypeTag](Obj:T) =ru.typeTag[T]
 }

}
